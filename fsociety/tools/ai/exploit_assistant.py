"""AI-powered exploitation assistant for intelligent penetration testing."""

from __future__ import annotations

import asyncio
from dataclasses import dataclass
from enum import Enum
from typing import Any

from rich.panel import Panel
from rich.syntax import Syntax
from rich.tree import Tree

from fsociety.ai.engine import get_ai_engine, AIResult, AnalysisType
from fsociety.console import console
from fsociety.core.config import get_config


class ExploitCategory(str, Enum):
    """Exploit categories."""
    WEB = "web"
    NETWORK = "network"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    PASSWORD = "password"
    SOCIAL_ENGINEERING = "social_engineering"
    WIRELESS = "wireless"
    PHYSICAL = "physical"


@dataclass
class ExploitSuggestion:
    """AI-generated exploit suggestion."""
    
    category: ExploitCategory
    name: str
    description: str
    difficulty: int  # 1-10
    success_probability: float  # 0.0-1.0
    requirements: list[str]
    steps: list[str]
    tools: list[str]
    countermeasures: list[str]
    references: list[str]
    code_example: str | None = None


class AIExploitAssistant:
    """AI-powered assistant for exploit development and execution."""
    
    def __init__(self) -> None:
        self.config = get_config()
        self.ai_engine = get_ai_engine()
        self._initialized = False
    
    async def initialize(self) -> None:
        """Initialize the AI assistant."""
        if not self.config.ai.enabled:
            console.print("[yellow]AI features are disabled. Enable in config.")
            return
        
        console.print("[cyan]Initializing AI Exploit Assistant...")
        await self.ai_engine.initialize()
        self._initialized = True
        console.print("[green]✓ AI Assistant ready!")
    
    async def analyze_target(
        self,
        target: str,
        scan_results: dict[str, Any],
    ) -> list[ExploitSuggestion]:
        """Analyze target and suggest exploits."""
        if not self._initialized:
            await self.initialize()
        
        console.print(f"[cyan]Analyzing {target} with AI...")
        
        # Get AI analysis
        ai_result = await self.ai_engine.analyze_vulnerability(target, scan_results)
        
        # Convert to exploit suggestions
        exploits = await self._generate_exploit_suggestions(target, ai_result, scan_results)
        
        return exploits
    
    async def _generate_exploit_suggestions(
        self,
        target: str,
        ai_result: AIResult,
        scan_results: dict[str, Any],
    ) -> list[ExploitSuggestion]:
        """Generate detailed exploit suggestions."""
        prompt = f"""
        Based on this vulnerability analysis for {target}:
        
        Severity: {ai_result.severity}
        Summary: {ai_result.summary}
        Details: {ai_result.details}
        
        Scan Results:
        {scan_results}
        
        Provide 3-5 specific exploit suggestions in JSON format:
        [
          {{
            "category": "web|network|privilege_escalation|password|social_engineering",
            "name": "Exploit Name",
            "description": "Detailed description",
            "difficulty": 1-10,
            "success_probability": 0.0-1.0,
            "requirements": ["requirement1", "requirement2"],
            "steps": ["step1", "step2", "step3"],
            "tools": ["tool1", "tool2"],
            "countermeasures": ["defense1", "defense2"],
            "references": ["CVE-XXXX", "URL"],
            "code_example": "Optional code snippet"
          }}
        ]
        
        Focus on realistic, actionable exploits.
        """
        
        response = await self.ai_engine._generate(prompt)
        
        # Parse response (simplified - real impl would use JSON parsing)
        exploits = self._parse_exploit_response(response)
        
        return exploits
    
    def _parse_exploit_response(self, response: str) -> list[ExploitSuggestion]:
        """Parse AI response into exploit suggestions."""
        # Simplified parser - real implementation would parse JSON
        return [
            ExploitSuggestion(
                category=ExploitCategory.WEB,
                name="SQL Injection Attack",
                description="Exploit SQL injection vulnerability to access database",
                difficulty=5,
                success_probability=0.75,
                requirements=["Access to vulnerable endpoint", "SQL knowledge"],
                steps=[
                    "Identify injection point",
                    "Test with payloads",
                    "Extract database schema",
                    "Dump sensitive data",
                ],
                tools=["sqlmap", "burp suite", "custom scripts"],
                countermeasures=[
                    "Use parameterized queries",
                    "Input validation",
                    "WAF deployment",
                ],
                references=["OWASP Top 10", "CWE-89"],
                code_example="' OR '1'='1",
            ),
            ExploitSuggestion(
                category=ExploitCategory.NETWORK,
                name="Buffer Overflow Exploitation",
                description="Exploit buffer overflow to gain code execution",
                difficulty=8,
                success_probability=0.60,
                requirements=["Binary analysis skills", "Debugger access"],
                steps=[
                    "Reverse engineer binary",
                    "Identify vulnerable function",
                    "Craft payload",
                    "Test exploit",
                    "Gain shell access",
                ],
                tools=["gdb", "pwntools", "metasploit"],
                countermeasures=[
                    "Enable ASLR",
                    "Stack canaries",
                    "DEP/NX bit",
                ],
                references=["CVE-2021-XXXXX"],
            ),
        ]
    
    async def generate_payload(
        self,
        exploit_type: str,
        target_info: dict[str, Any],
    ) -> str:
        """Generate exploit payload using AI."""
        if not self._initialized:
            await self.initialize()
        
        prompt = f"""
        Generate an exploit payload for:
        Type: {exploit_type}
        Target: {target_info}
        
        Requirements:
        1. Working proof-of-concept code
        2. Clear comments explaining each step
        3. Error handling
        4. Safety checks
        
        Provide complete, executable code.
        """
        
        console.print("[cyan]Generating payload with AI...")
        payload = await self.ai_engine._generate(prompt)
        
        return payload
    
    async def reverse_engineer_binary(
        self,
        binary_path: str,
    ) -> dict[str, Any]:
        """Use AI to assist in binary reverse engineering."""
        if not self._initialized:
            await self.initialize()
        
        prompt = f"""
        Analyze this binary: {binary_path}
        
        Provide:
        1. Architecture and compiler information
        2. Potential vulnerabilities
        3. Interesting functions
        4. Security mechanisms (ASLR, DEP, etc.)
        5. Suggested attack vectors
        """
        
        console.print("[cyan]Analyzing binary with AI...")
        analysis = await self.ai_engine._generate(prompt)
        
        return {"analysis": analysis, "binary": binary_path}
    
    async def suggest_privilege_escalation(
        self,
        system_info: dict[str, Any],
    ) -> list[str]:
        """Suggest privilege escalation techniques."""
        if not self._initialized:
            await self.initialize()
        
        prompt = f"""
        System Information:
        {system_info}
        
        Suggest privilege escalation techniques:
        1. Kernel exploits
        2. SUID/SUDO misconfigurations
        3. Writable files/directories
        4. Service vulnerabilities
        5. Scheduled tasks
        
        Rank by likelihood of success.
        """
        
        response = await self.ai_engine._generate(prompt)
        
        # Parse suggestions
        suggestions = response.split("\n")
        return [s.strip() for s in suggestions if s.strip()]
    
    async def interactive_mode(self) -> None:
        """Run interactive AI assistant mode."""
        if not self._initialized:
            await self.initialize()
        
        console.print("\n[cyan]AI Exploit Assistant - Interactive Mode")
        console.print("[dim]Type 'help' for commands, 'exit' to quit\n")
        
        commands = {
            "analyze": "Analyze a target",
            "payload": "Generate exploit payload",
            "privesc": "Privilege escalation suggestions",
            "binary": "Reverse engineer binary",
            "help": "Show this help",
            "exit": "Exit assistant",
        }
        
        while True:
            try:
                user_input = input("\n[AI]> ").strip().lower()
                
                if not user_input:
                    continue
                
                match user_input:
                    case "exit" | "quit":
                        console.print("[yellow]Goodbye!")
                        break
                    
                    case "help":
                        console.print("\n[cyan]Available Commands:")
                        for cmd, desc in commands.items():
                            console.print(f"  [yellow]{cmd:12}[/yellow] {desc}")
                    
                    case "analyze":
                        target = input("Target: ").strip()
                        # Would call analyze_target with real scan results
                        console.print(f"[cyan]Analyzing {target}...")
                        console.print("[green]Analysis complete! (demo)")
                    
                    case "payload":
                        exploit_type = input("Exploit type: ").strip()
                        payload = await self.generate_payload(
                            exploit_type,
                            {"target": "example"},
                        )
                        
                        syntax = Syntax(
                            payload[:500],
                            "python",
                            theme="monokai",
                            line_numbers=True,
                        )
                        console.print(syntax)
                    
                    case "privesc":
                        console.print("[cyan]Analyzing system for privesc vectors...")
                        suggestions = await self.suggest_privilege_escalation(
                            {"os": "linux", "user": "www-data"}
                        )
                        
                        tree = Tree("[bold cyan]Privilege Escalation Suggestions")
                        for suggestion in suggestions[:5]:
                            tree.add(suggestion)
                        console.print(tree)
                    
                    case _:
                        # General query
                        console.print("[dim]Thinking...")
                        response = await self.ai_engine._generate(user_input)
                        console.print(f"\n[cyan]{response[:500]}...")
            
            except KeyboardInterrupt:
                console.print("\n[yellow]Use 'exit' to quit")
            except Exception as e:
                console.print(f"[red]Error: {e}")
    
    def display_exploit_suggestions(
        self,
        exploits: list[ExploitSuggestion],
    ) -> None:
        """Display exploit suggestions in a formatted way."""
        console.print("\n[bold cyan]═══ AI Exploit Suggestions ═══")
        
        for i, exploit in enumerate(exploits, 1):
            # Create panel for each exploit
            difficulty_color = self._get_difficulty_color(exploit.difficulty)
            success_color = self._get_success_color(exploit.success_probability)
            
            content = f"""
[yellow]Category:[/yellow] {exploit.category.value}
[yellow]Difficulty:[/yellow] [{difficulty_color}]{exploit.difficulty}/10[/{difficulty_color}]
[yellow]Success Rate:[/yellow] [{success_color}]{exploit.success_probability:.0%}[/{success_color}]

[bold]Description:[/bold]
{exploit.description}

[bold]Requirements:[/bold]
{self._format_list(exploit.requirements)}

[bold]Tools:[/bold]
{self._format_list(exploit.tools)}

[bold]Steps:[/bold]
{self._format_numbered_list(exploit.steps)}

[bold]Countermeasures:[/bold]
{self._format_list(exploit.countermeasures)}
            """
            
            if exploit.code_example:
                content += f"\n[bold]Code Example:[/bold]\n{exploit.code_example}"
            
            panel = Panel(
                content.strip(),
                title=f"[{i}] {exploit.name}",
                border_style="cyan",
                expand=False,
            )
            
            console.print(panel)
    
    def _get_difficulty_color(self, difficulty: int) -> str:
        """Get color for difficulty level."""
        if difficulty <= 3:
            return "green"
        elif difficulty <= 6:
            return "yellow"
        else:
            return "red"
    
    def _get_success_color(self, probability: float) -> str:
        """Get color for success probability."""
        if probability >= 0.7:
            return "green"
        elif probability >= 0.4:
            return "yellow"
        else:
            return "red"
    
    def _format_list(self, items: list[str]) -> str:
        """Format list items."""
        return "\n".join(f"  • {item}" for item in items)
    
    def _format_numbered_list(self, items: list[str]) -> str:
        """Format numbered list."""
        return "\n".join(f"  {i}. {item}" for i, item in enumerate(items, 1))


# Create global instance
_exploit_assistant: AIExploitAssistant | None = None


def get_exploit_assistant() -> AIExploitAssistant:
    """Get global exploit assistant instance."""
    global _exploit_assistant
    if _exploit_assistant is None:
        _exploit_assistant = AIExploitAssistant()
    return _exploit_assistant


# CLI command
async def run_ai_assistant() -> None:
    """Run AI assistant from CLI."""
    assistant = get_exploit_assistant()
    await assistant.interactive_mode()


if __name__ == "__main__":
    asyncio.run(run_ai_assistant())